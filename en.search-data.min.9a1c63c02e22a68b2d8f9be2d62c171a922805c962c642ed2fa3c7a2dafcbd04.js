'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-k8s/docs/basic/container/docker/image/alpine/','title':"alpine",'content':"alpine 安装 telnet apk add busybox-extras\n"});index.add({'id':1,'href':'/study-k8s/docs/basic/component/api-server/','title':"api-server",'content':"api-server 基础 "});index.add({'id':2,'href':'/study-k8s/docs/basic/container/docker/','title':"Docker",'content':"Docker 基础 "});index.add({'id':3,'href':'/study-k8s/docs/basic/container/docker/image/','title':"Docker 镜像",'content':"Docker 镜像 "});index.add({'id':4,'href':'/study-k8s/docs/basic/network/port/','title':"K8s 端口",'content':"K8s 端口 总的来说，port 和 nodePort 都是 service 的端口，前者暴露给集群内客户访问服务，后者暴露给集群外客户访问服务。从这两个端口到来的数据都需要经过反向代理 kube-proxy 流入后端 pod 的 targetPod，从而到达 pod 上的容器内。\npod 模板 作用类似于 docker -p 选项 containerPort: 容器需要暴露的端口 hostPort: 容器暴露的端口映射到的主机端口\nservice (ClusterIP) port: service 中 clusterIP 对应的端口 targetPort: clusterIP 作为负载均衡， 后端目标实例 (容器) 的端口\nservice (NodePort) nodePort: cluster ip 只能集群内部访问 (源与目标需要满足两个条件: kube-proxy 正常运行，跨主机容器网络通信正常)， nodePort 会在每个 kubelet 节点的宿主机开启一个端口，用于应用集群外部访问\nnodePort 到 clusterIP 的映射，是 kube-proxy 实现的。\n"});index.add({'id':5,'href':'/study-k8s/docs/basic/network/kubedns/','title':"KubeDNS",'content':"KubeDNS 在 Linux 系统中，/etc/resolv.conf 是存储 DNS 服务器的文件， 普通 Pod 的 /etc/resolv.conf 文件应该存储的是 kube-dns 的 Service IP。\nnameserver 10.99.0.2 # 这里存储的是kube-dns的Service IP search default.svc.cluster.local. svc.cluster.local. cluster.local. options ndots:5 k8s 中域名是如何被解析的 在 k8s 中，一个 Pod 如果要访问相同同 Namespace 下的 Service（比如 user-svc），那么只需要 curl user-svc。 如果 Pod 和 Service 不在同一域名下，那么就需要在 Service Name 之后添加上 Service 所在的 Namespace（比如 beta），curl user-svc.beta。 那么 k8s 是如何知道这些域名是内部域名并为他们做解析的呢？\n无论是在 宿主机 或者是在 k8s 集群中，DNS 解析会依赖这个三个文件\n /etc/host.conf /etc/hosts /etc/resolv.conf  /etc/resolv.conf resolv.conf 是 Pod 在 dnsPolicy: ClusterFirst 的情况下，k8s 为其自动生成的。 在该 Pod 内请求的所有的域名解析都需要经过 DNS Service 进行解析，不管是集群内部域名还是外部域名。\n每行都会以一个关键字开头，然后跟配置参数。\n在集群中主要使用到的关键词有 3 个\n nameserver 定义 DNS 服务器的 IP 地址（Kube-DNS 的 Service IP） search 定义域名的搜索列表，当查询的域名中包含的 . 的数量少于 options.ndots 的值时，会依次匹配列表中的每个值 options 定义域名查找时的配置信息  nameserver、search 和 options 都是可以通过 dnsConfig 字段进行配置的，详细参考官方文档\n例如\nnameserver 10.250.0.10 search default.svc.cluster.local svc.cluster.local cluster.local options ndots:5 nameserver nameserver 所对应的地址正是 DNS Service 的 Cluster IP（该值在启动 kubelet 的时候，通过 clusterDNS 指定）。\nsearch 域 search 域默认包含了 namespace.svc.cluster.local、svc.cluster.local 和 cluster.local 三种。\n当我们在 Pod 中访问 a Service 时（ curl a ），会选择 nameserver 10.250.0.10 进行解析，然后依次带入 search 域进行 DNS 查找，直到找到为止。\n# curl a a.default.svc.cluster.local 显然因为 Pod 和 a Service 在同一 Namespace 下，所以第一次 lookup 就能找到。\n如果 Pod 要访问不同 Namespace（例如： beta ）下的 Service b （ curl b.beta ），会经过两次 DNS 查找，分别是\n# curl b.beta b.beta.default.svc.cluster.local # Not Found b.beta.svc.cluster.local # Found 正是因为 search 的顺序性，所以访问同一 Namespace 下的 Service， curl a 是要比 curl a.default 的效率更高的，因为后者多经过了一次 DNS 解析。\n# curl a a.default.svc.cluster.local # Found # curl a.default b.default.default.svc.cluster.local # Not Found b.default.svc.cluster.local # Found options ndots:5，表示：\n 如果需要 lookup 的 Domain 中包含少于 5 个 . ，那么将会被当做非绝对域名， 如果需要查询的 Domain 中包含大于或等于 5 个 . ，那么就会被当做绝对域名。  如果是绝对域名则不会走 search 域，如果是非绝对域名，就会按照 search 域中进行逐一匹配查询， 如果 search 走完了都没有找到，那么就会使用原域名进行查找。\n优化外网域名解析 在真正解析 http://iftech.io 之前，经历了\niftech.io.default.svc.cluster.local. -\u0026gt; iftech.io.svc.cluster.local. -\u0026gt; iftech.io.com.cluster.local. -\u0026gt; iftech.io. 这样也就意味着前 3 次 DNS 请求是浪费的，没有意义的。\n 直接使用绝对域名 这是最简单直接的优化方式，可以直接在要访问的域名后面加上 . 如：iftech.io. ，这样就可以避免走 search 域进行匹配。 配置 ndots 比如配置 ndots:1，iftech.io. 就会使用原域名进行查找。  如何进入 kube-dns 容器进行抓包 DNS 容器往往不具备 bash，所以不能通过 docker exec 或者 kubectl exec 的方式进入容器抓包。\ndocker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; dns_container_id # 进入 container 的 network namespace nsenter -n -t pid # 对 53 端口进行抓包 tcpdump -i eth0 -N udp dst port 53 dnsPolicy ClusterFirst（默认） 优先使用 kubedns 或者 coredns 进行域名解析。如果解析不成功，才会使用宿主机的 DNS 配置进行解析。\nClusterFirstWithHostNet 当一个 Pod 以 HOST 模式（和宿主机共享网络，hostNetwork: true）启动时，这个 POD 中的所有容器都会使用宿主机的 /etc/resolv.conf 配置进行 DNS 查询。 但是如果在 Pod 中仍然还想继续使用 k8s 集群 的 DNS 服务时，就需要将 dnsPolicy 设置为 ClusterFirstWithHostNet。\nDefault 让 kubelet 来决定 Pod 内的 DNS 使用哪种 DNS 策略。 kubelet 的默认方式，其实就是使用宿主机的 /etc/resolv.conf 来进行解析。 你可以通过设置 kubelet 的启动参数， \u0026ndash;resolv-conf=/etc/resolv.conf 来决定该 DNS 服务使用的解析文件的地址\n当我们部署集群 DNS 服务的时候，一般就需要将 dnsPolicy 设置成 Default， 而并非使用默认值 ClusterFirst，否则该 DNS 服务的上游解析地址会变成它自身的 Service 的 ClusterIP（我解析我自己），导致域名无法解析。\nNone 不会使用集群和宿主机的 DNS 策略，而是和 dnsConfig 配合一起使用，来自定义 DNS 配置，否则在提交修改时报错。\nkube-dns 组成 kubedns 依赖 client-go 中的 informer 机制监视 k8s 中的 Service 和 Endpoint 的变化，并将这些结构维护进内存来服务内部 DNS 解析请求。\ndnsmasq 区分 Domain 是集群内部还是外部，给外部域名提供上游解析，内部域名发往 10053 端口，并将解析结果缓存，提高解析效率。\nsidecar 对 kubedns 和 dnsmasq 进行健康检查和收集监控指标。\n如何调试 DNS 解析 参考 k8smeetup：调试 DNS 解析\n"});index.add({'id':6,'href':'/study-k8s/docs/basic/resource/pod/','title':"Pod",'content':"Pod "});index.add({'id':7,'href':'/study-k8s/docs/basic/quick-start/install/','title':"安装",'content':"Kubernetes 安装 Minikube Docker Desktop MicroK8s "});index.add({'id':8,'href':'/study-k8s/docs/basic/quick-start/','title':"快速上手",'content':"Kubernetes 快速上手 架构 概念 安装 简单使用 "});index.add({'id':9,'href':'/study-k8s/docs/appendix/tutorial/','title':"教程",'content':"Java 教程 基础 进阶 Effective Java  第 3 版中文版：sjsdfg.github.io/effective-java-3rd-chinese  Java 编程思想  第 5 版中文版：lingcoder.github.io/OnJava8  高阶 "});index.add({'id':10,'href':'/study-k8s/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':11,'href':'/study-k8s/docs/basic/best-practice/spec/','title':"编程规范",'content':"Kubernetes 编程规范 "});index.add({'id':12,'href':'/study-k8s/docs/basic/resource/configmap/','title':"ConfigMap",'content':"ConfigMap 基础 ConfigMap 在运行时会将配置文件、命令行参数、环境变量、端口号以及其他配置工件绑定到 Pod 的容器和系统组件。借助 ConfigMap，您可以将配置与 Pod 和组件分开，这有助于保持工作负载的可移植性，使其配置更易于更改和管理，并防止将配置数据硬编码到 Pod 规范。\nConfigMap 可用于存储和共享非敏感、未加密的配置信息。要在集群中使用敏感信息，您必须使用 Secret。\n创建 ConfigMap 使用以下命令创建 ConfigMap：\nkubectl create configmap [NAME] [DATA]\n[DATA] 可以是： 包含一个或多个配置文件的目录的路径，使用 \u0026ndash;from-file 标志指示 键值对，每个键值对都使用 \u0026ndash;from-literal 标志指定 如需详细了解 kubectl create，请参阅参考文档。\n您还可以通过在 YAML 清单文件中定义 ConfigMap 对象并使用 kubectl create -f [FILE] 部署对象来创建 ConfigMap。\n使用 ConfigMap apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never "});index.add({'id':13,'href':'/study-k8s/docs/basic/network/coredns/','title':"CoreDNS",'content':"CoreDNS CoreDNS vs KubeDNS 在 kube-dns 中，一个 pod 内使用了数个容器：kubedns、dnsmasq 和 sidecar。\n kubedns 容器监视 Kubernetes API 并基于 Kubernetes DNS 规范提供 DNS 记录， dnsmasq 提供缓存和存根域支持， sidecar 提供指标和健康检查。  此设置会导致一些问题随着时间的推移而出现。首先，dnsmasq 中的安全漏洞导致过去需要发布 Kubernetes 安全补丁。 此外，由于 dnsmasq 处理存根域，但 kubedns 处理 External Services，因此你无法在外部服务中使用存根域，这非常限制该功能（参阅 dns＃131）。\n在 CoreDNS 中，所有这些功能都在一个容器中完成 —— 该容器运行用 Go 编写的进程。 启用的不同插件来复制（并增强）kube-dns 中的功能。\n"});index.add({'id':14,'href':'/study-k8s/docs/basic/resource/deployment/','title':"Deployment",'content':"Deployment "});index.add({'id':15,'href':'/study-k8s/docs/basic/kubectl/','title':"Kubectl",'content':"Kubectl 常用命令 kubectl get  获取 service ip, port  kubectl get service/servicename -o jsonpath='{.spec.clusterIP}:{.spec.ports[*].port}' 参考 kubectl Cheat Sheet "});index.add({'id':16,'href':'/study-k8s/docs/basic/component/schedule/','title':"Schedule",'content':"Schedule 基础 "});index.add({'id':17,'href':'/study-k8s/docs/appendix/interview/basic/','title':"基础",'content':"Java 基础面试题 "});index.add({'id':18,'href':'/study-k8s/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':19,'href':'/study-k8s/docs/appendix/interview/advanced/','title':"进阶",'content':"Java 进阶面试题 "});index.add({'id':20,'href':'/study-k8s/docs/appendix/interview/','title':"面试题",'content':"Java 面试题 基础题 进阶题 高阶题 "});index.add({'id':21,'href':'/study-k8s/docs/basic/component/controller-manager/','title':"Controller Manager",'content':"Controller Manager 基础 "});index.add({'id':22,'href':'/study-k8s/docs/basic/resource/crd/','title':"CRD",'content':"CRD "});index.add({'id':23,'href':'/study-k8s/docs/basic/tool/helm/','title':"Helm",'content':"Helm  Helm is the best way to find, share, and use software built for Kubernetes.\n 官网：https://helm.sh\n"});index.add({'id':24,'href':'/study-k8s/docs/basic/component/','title':"核心组件",'content':"https://github.com/istio/istio\n"});index.add({'id':25,'href':'/study-k8s/docs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':26,'href':'/study-k8s/docs/appendix/interview/expert/','title':"高阶",'content':"Java 高阶面试题 "});index.add({'id':27,'href':'/study-k8s/docs/basic/resource/','title':"API 资源",'content':""});index.add({'id':28,'href':'/study-k8s/docs/basic/component/kube-proxy/','title':"Kube-proxy",'content':"Kube-proxy 基础 "});index.add({'id':29,'href':'/study-k8s/docs/basic/component/kubelet/','title':"Kubelet",'content':"Kubelet 基础 Kubelet 创建进程 "});index.add({'id':30,'href':'/study-k8s/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':31,'href':'/study-k8s/docs/basic/network/','title':"K8s 网络",'content':""});index.add({'id':32,'href':'/study-k8s/docs/basic/container/','title':"容器运行时",'content':""});index.add({'id':33,'href':'/study-k8s/docs/basic/best-practice/','title':"最佳实践",'content':"Kubernetes 最佳实践 "});index.add({'id':34,'href':'/study-k8s/docs/basic/version/','title':"版本",'content':"Kubernetes 版本 "});index.add({'id':35,'href':'/study-k8s/docs/basic/debug/','title':"除错",'content':"Kubernetes 除错 参考：监控、日志和排错\n"});index.add({'id':36,'href':'/study-k8s/docs/basic/tool/','title':"常用工具",'content':""});index.add({'id':37,'href':'/study-k8s/categories/','title':"Categories",'content':""});index.add({'id':38,'href':'/study-k8s/docs/','title':"Docs",'content':""});index.add({'id':39,'href':'/study-k8s/tags/','title':"Tags",'content':""});index.add({'id':40,'href':'/study-k8s/','title':"首页",'content':""});})();