'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-kubernetes/docs/basic/container/docker/image/alpine/','title':"alpine",'content':"alpine 安装 telnet apk add busybox-extras\n"});index.add({'id':1,'href':'/study-kubernetes/docs/basic/component/api-server/','title':"api-server",'content':"api-server 基础 "});index.add({'id':2,'href':'/study-kubernetes/docs/basic/container/docker/','title':"Docker",'content':"Docker 基础 "});index.add({'id':3,'href':'/study-kubernetes/docs/basic/container/docker/image/','title':"Docker 镜像",'content':"Docker 镜像 "});index.add({'id':4,'href':'/study-kubernetes/docs/basic/network/port/','title':"K8s 端口",'content':"K8s 端口  service 的端口  port：负责处理对内的通信，  访问方式：clusterIP:port   nodePort：在 node 上，负责对外通信  访问方式：NodeIP:NodePort     pod 的端口  targetPort：在 pod 上  从 port 和 nodePort 上来的流量，经过 kube-proxy 流入到后端 pod 的 targetPort 上，最后进入容器     容器的端口  containerPort：在容器上，用于被 pod 绑定   主机的端口  hostPort：容器暴露的端口映射到的主机端口  尽量不要为 Pod 指定 hostPort 将 Pod 绑定到 hostPort 时，它会限制 Pod 可以调度的位置数，因为每个 \u0026lt;hostIP, hostPort, protocol\u0026gt; 组合必须是唯一的 如果您没有明确指定 hostIP 和 protocol，Kubernetes 将使用 0.0.0.0 作为默认 hostIP 和 TCP 作为默认 protocol      pod 模板指定端口 作用类似于 docker -p 选项\n containerPort: 容器需要暴露的端口 hostPort: 容器暴露的端口映射到的主机端口   service 指定端口 service (ClusterIP)  port: service 中 clusterIP 对应的端口 targetPort: clusterIP 作为负载均衡，后端目标实例 (容器) 的端口  service (NodePort)  nodePort: cluster ip 只能集群内部访问  源与目标需要满足两个条件:  kube-proxy 正常运行 跨主机容器网络通信正常   nodePort 会在每个 kubelet 节点的宿主机开启一个端口，用于应用集群外部访问 nodePort 到 clusterIP 的映射，是 kube-proxy 实现的。     参考  配置最佳实践 从外部访问 Kubernetes 中的 Pod  关于在 kubenretes 中暴露 Pod 及服务的 5 种方式    "});index.add({'id':5,'href':'/study-kubernetes/docs/basic/network/kubedns/','title':"KubeDNS",'content':"KubeDNS 在 Linux 系统中，/etc/resolv.conf 是存储 DNS 服务器的文件， 普通 Pod 的 /etc/resolv.conf 文件应该存储的是 kube-dns 的 Service IP。\nnameserver 10.99.0.2 # 这里存储的是kube-dns的Service IP search default.svc.cluster.local. svc.cluster.local. cluster.local. options ndots:5 k8s 中域名是如何被解析的 在 k8s 中，一个 Pod 如果要访问相同同 Namespace 下的 Service（比如 user-svc），那么只需要 curl user-svc。 如果 Pod 和 Service 不在同一域名下，那么就需要在 Service Name 之后添加上 Service 所在的 Namespace（比如 beta），curl user-svc.beta。 那么 k8s 是如何知道这些域名是内部域名并为他们做解析的呢？\n无论是在 宿主机 或者是在 k8s 集群中，DNS 解析会依赖这个三个文件\n /etc/host.conf /etc/hosts /etc/resolv.conf  /etc/resolv.conf resolv.conf 是 Pod 在 dnsPolicy: ClusterFirst 的情况下，k8s 为其自动生成的。 在该 Pod 内请求的所有的域名解析都需要经过 DNS Service 进行解析，不管是集群内部域名还是外部域名。\n每行都会以一个关键字开头，然后跟配置参数。\n在集群中主要使用到的关键词有 3 个\n nameserver 定义 DNS 服务器的 IP 地址（Kube-DNS 的 Service IP） search 定义域名的搜索列表，当查询的域名中包含的 . 的数量少于 options.ndots 的值时，会依次匹配列表中的每个值 options 定义域名查找时的配置信息  nameserver、search 和 options 都是可以通过 dnsConfig 字段进行配置的，详细参考官方文档\n例如\nnameserver 10.250.0.10 search default.svc.cluster.local svc.cluster.local cluster.local options ndots:5 nameserver nameserver 所对应的地址正是 DNS Service 的 Cluster IP（该值在启动 kubelet 的时候，通过 clusterDNS 指定）。\nsearch 域 search 域默认包含了 namespace.svc.cluster.local、svc.cluster.local 和 cluster.local 三种。\n当我们在 Pod 中访问 a Service 时（ curl a ），会选择 nameserver 10.250.0.10 进行解析，然后依次带入 search 域进行 DNS 查找，直到找到为止。\n# curl a a.default.svc.cluster.local 显然因为 Pod 和 a Service 在同一 Namespace 下，所以第一次 lookup 就能找到。\n如果 Pod 要访问不同 Namespace（例如： beta ）下的 Service b （ curl b.beta ），会经过两次 DNS 查找，分别是\n# curl b.beta b.beta.default.svc.cluster.local # Not Found b.beta.svc.cluster.local # Found 正是因为 search 的顺序性，所以访问同一 Namespace 下的 Service， curl a 是要比 curl a.default 的效率更高的，因为后者多经过了一次 DNS 解析。\n# curl a a.default.svc.cluster.local # Found # curl a.default b.default.default.svc.cluster.local # Not Found b.default.svc.cluster.local # Found options ndots:5，表示：\n 如果需要 lookup 的 Domain 中包含少于 5 个 . ，那么将会被当做非绝对域名， 如果需要查询的 Domain 中包含大于或等于 5 个 . ，那么就会被当做绝对域名。  如果是绝对域名则不会走 search 域，如果是非绝对域名，就会按照 search 域中进行逐一匹配查询， 如果 search 走完了都没有找到，那么就会使用原域名进行查找。\n优化外网域名解析 在真正解析 http://iftech.io 之前，经历了\niftech.io.default.svc.cluster.local. -\u0026gt; iftech.io.svc.cluster.local. -\u0026gt; iftech.io.com.cluster.local. -\u0026gt; iftech.io. 这样也就意味着前 3 次 DNS 请求是浪费的，没有意义的。\n 直接使用绝对域名 这是最简单直接的优化方式，可以直接在要访问的域名后面加上 . 如：iftech.io. ，这样就可以避免走 search 域进行匹配。 配置 ndots 比如配置 ndots:1，iftech.io. 就会使用原域名进行查找。  如何进入 kube-dns 容器进行抓包 DNS 容器往往不具备 bash，所以不能通过 docker exec 或者 kubectl exec 的方式进入容器抓包。\ndocker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; dns_container_id # 进入 container 的 network namespace nsenter -n -t pid # 对 53 端口进行抓包 tcpdump -i eth0 -N udp dst port 53 dnsPolicy ClusterFirst（默认） 优先使用 kubedns 或者 coredns 进行域名解析。如果解析不成功，才会使用宿主机的 DNS 配置进行解析。\nClusterFirstWithHostNet 当一个 Pod 以 HOST 模式（和宿主机共享网络，hostNetwork: true）启动时，这个 POD 中的所有容器都会使用宿主机的 /etc/resolv.conf 配置进行 DNS 查询。 但是如果在 Pod 中仍然还想继续使用 k8s 集群 的 DNS 服务时，就需要将 dnsPolicy 设置为 ClusterFirstWithHostNet。\nDefault 让 kubelet 来决定 Pod 内的 DNS 使用哪种 DNS 策略。 kubelet 的默认方式，其实就是使用宿主机的 /etc/resolv.conf 来进行解析。 你可以通过设置 kubelet 的启动参数， \u0026ndash;resolv-conf=/etc/resolv.conf 来决定该 DNS 服务使用的解析文件的地址\n当我们部署集群 DNS 服务的时候，一般就需要将 dnsPolicy 设置成 Default， 而并非使用默认值 ClusterFirst，否则该 DNS 服务的上游解析地址会变成它自身的 Service 的 ClusterIP（我解析我自己），导致域名无法解析。\nNone 不会使用集群和宿主机的 DNS 策略，而是和 dnsConfig 配合一起使用，来自定义 DNS 配置，否则在提交修改时报错。\nkube-dns 组成 kubedns 依赖 client-go 中的 informer 机制监视 k8s 中的 Service 和 Endpoint 的变化，并将这些结构维护进内存来服务内部 DNS 解析请求。\ndnsmasq 区分 Domain 是集群内部还是外部，给外部域名提供上游解析，内部域名发往 10053 端口，并将解析结果缓存，提高解析效率。\nsidecar 对 kubedns 和 dnsmasq 进行健康检查和收集监控指标。\n如何调试 DNS 解析 参考 k8smeetup：调试 DNS 解析\n"});index.add({'id':6,'href':'/study-kubernetes/docs/basic/resource/pod/','title':"Pod",'content':"Pod "});index.add({'id':7,'href':'/study-kubernetes/docs/basic/quick-start/install/','title':"安装",'content':"Kubernetes 安装 Minikube Docker Desktop MicroK8s "});index.add({'id':8,'href':'/study-kubernetes/docs/basic/quick-start/','title':"快速上手",'content':"Kubernetes 快速上手 架构 概念 安装 简单使用 "});index.add({'id':9,'href':'/study-kubernetes/docs/appendix/tutorial/','title':"教程",'content':"Kubernetes 教程 基础 进阶 高阶 "});index.add({'id':10,'href':'/study-kubernetes/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':11,'href':'/study-kubernetes/docs/basic/best-practice/spec/','title':"编程规范",'content':"Kubernetes 编程规范 "});index.add({'id':12,'href':'/study-kubernetes/docs/basic/resource/configmap/','title':"ConfigMap",'content':"ConfigMap 基础 ConfigMap 在运行时会将配置文件、命令行参数、环境变量、端口号以及其他配置工件绑定到 Pod 的容器和系统组件。借助 ConfigMap，您可以将配置与 Pod 和组件分开，这有助于保持工作负载的可移植性，使其配置更易于更改和管理，并防止将配置数据硬编码到 Pod 规范。\nConfigMap 可用于存储和共享非敏感、未加密的配置信息。要在集群中使用敏感信息，您必须使用 Secret。\n创建 ConfigMap 使用以下命令创建 ConfigMap：\nkubectl create configmap [NAME] [DATA]\n[DATA] 可以是： 包含一个或多个配置文件的目录的路径，使用 \u0026ndash;from-file 标志指示 键值对，每个键值对都使用 \u0026ndash;from-literal 标志指定 如需详细了解 kubectl create，请参阅参考文档。\n您还可以通过在 YAML 清单文件中定义 ConfigMap 对象并使用 kubectl create -f [FILE] 部署对象来创建 ConfigMap。\n使用 ConfigMap apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never "});index.add({'id':13,'href':'/study-kubernetes/docs/basic/network/coredns/','title':"CoreDNS",'content':"CoreDNS CoreDNS vs KubeDNS 在 kube-dns 中，一个 pod 内使用了数个容器：kubedns、dnsmasq 和 sidecar。\n kubedns 容器监视 Kubernetes API 并基于 Kubernetes DNS 规范提供 DNS 记录， dnsmasq 提供缓存和存根域支持， sidecar 提供指标和健康检查。  此设置会导致一些问题随着时间的推移而出现。首先，dnsmasq 中的安全漏洞导致过去需要发布 Kubernetes 安全补丁。 此外，由于 dnsmasq 处理存根域，但 kubedns 处理 External Services，因此你无法在外部服务中使用存根域，这非常限制该功能（参阅 dns＃131）。\n在 CoreDNS 中，所有这些功能都在一个容器中完成 —— 该容器运行用 Go 编写的进程。 启用的不同插件来复制（并增强）kube-dns 中的功能。\n"});index.add({'id':14,'href':'/study-kubernetes/docs/basic/resource/deployment/','title':"Deployment",'content':"Deployment "});index.add({'id':15,'href':'/study-kubernetes/docs/basic/kubectl/','title':"Kubectl",'content':"Kubectl 常用命令 kubectl get  获取 service ip, port  kubectl get service/servicename -o jsonpath='{.spec.clusterIP}:{.spec.ports[*].port}' 参考 kubectl Cheat Sheet "});index.add({'id':16,'href':'/study-kubernetes/docs/basic/component/schedule/','title':"Schedule",'content':"Schedule 基础 "});index.add({'id':17,'href':'/study-kubernetes/docs/appendix/interview/basic/','title':"基础",'content':"Kubernetes 基础面试题 "});index.add({'id':18,'href':'/study-kubernetes/docs/design/','title':"第二部分 设计",'content':""});index.add({'id':19,'href':'/study-kubernetes/docs/appendix/interview/advanced/','title':"进阶",'content':"Kubernetes 进阶面试题 "});index.add({'id':20,'href':'/study-kubernetes/docs/appendix/interview/','title':"面试题",'content':"面试题 头条人选一（最近一周刚面试，面试岗位是头条杭州的 docker、k8s 工程师） 1.解释一下 acid 2.数据库的隔离级别 3.每个隔离级别的实现原理 4.讲一下分布式事务现有的方案，优缺点 5.说一下 cgroup 原理 6.说一下 mesos，k8s 的架构 7.说一下 actor 编程模型的原理和意义 算法：输出所有出现次数大于 n/k 的数,如果没有这样的数,请输出”-1“。 人选反馈：面试官会抓住一个点一直追问，问的比较细。\n头条人选二（两周前面试 paas 平台开发工程师） 一面 1.字符串原地反转 2.软连接和硬连接的区别 3.前序和中序构造二叉树 4.10 亿个数字排序 5.大型企业的上线流程 二面 连续子数组的最大和 链表回文 三面 基于人选项目去发问，偏业务，没有算法题，还问到一些开源组件的使用情况。\n头条人选三（面试基础架构部门容器岗位）\n 系统 （Linux 下面进程是如何调度的，进程的优先级），有没有遇到过问题，描述原因和解决方法 2.网络 TIME_WAIT 状态出现的原因，排查的思路，有没有调优的方法 数据库 MyISAM 和 InnoDB 的简单区别 Docker/K8s CGroup 如何做 cpu 的资源限制，哪几种限制方式 K8s 中的 request 和 limit 是如何实现的 K8s 中的 rc、rs、deployment 的区别，特点 5.算法 合并两个有序链表  头条人选四（基础架构部门研发） docker pull 镜像原理\nregistry 镜像存储原理\nk8s deployment 创建过程\ngpu 资源共享\nscheduler 工作原理\ndocker 架构\ndocker exec 过程\ngoroutine 挂起\n实现阻塞队列\n项目\nlinux 进程调度\nhttp 请求过程\ntcp 建立连接和断开连接\ngoroutine 原理\nflannel 工作原理\n头条人选五（devops 偏容器的人选） 服务器负载是怎么计算的 如何查看服务执行卡住时服务器做了哪些事 查看进程打开哪些文件，查看哪些进程打开文件多 docker 网络模式有几种 分别是做什么 浏览器输入域名到返回结果过程 DNS 使用了什么协议，为什么要用这种协议 tcp 协议如何保证传输安全 timewait 状态的前后过程以及 timewait 过多时怎么处理 怎么优化 K8S 是怎么调度的 iptables 主要有哪些链和哪些表，分别是做什么用 docker 会调用 iptables 的哪些链 常驻空间和虚拟空间有什么区别 网络加速或者网络优化是怎么来做的，服务端和客户端分别可以做哪些 动态 CDN 和静态 CDN 的区别 算法题： 求两个文本文件的交集，并输出，比如 ABC 在 a.txt 有 5 行，在 b.txt 有 3 行 那么在结果文件中输出 3 行\n"});index.add({'id':21,'href':'/study-kubernetes/docs/basic/component/controller-manager/','title':"Controller Manager",'content':"Controller Manager 基础 "});index.add({'id':22,'href':'/study-kubernetes/docs/basic/resource/crd/','title':"CRD",'content':"CRD "});index.add({'id':23,'href':'/study-kubernetes/docs/basic/tool/helm/','title':"Helm",'content':"Helm  Helm is the best way to find, share, and use software built for Kubernetes.\n 官网：https://helm.sh\n"});index.add({'id':24,'href':'/study-kubernetes/docs/basic/component/','title':"核心组件",'content':"https://github.com/istio/istio\n"});index.add({'id':25,'href':'/study-kubernetes/docs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':26,'href':'/study-kubernetes/docs/appendix/interview/expert/','title':"高阶",'content':"Kubernetes 高阶面试题 "});index.add({'id':27,'href':'/study-kubernetes/docs/basic/resource/','title':"API 资源",'content':""});index.add({'id':28,'href':'/study-kubernetes/docs/basic/component/kube-proxy/','title':"Kube-proxy",'content':"Kube-proxy 基础 "});index.add({'id':29,'href':'/study-kubernetes/docs/basic/component/kubelet/','title':"Kubelet",'content':"Kubelet 基础 Kubelet 创建进程 参考：白话 Kubernetes Runtime\n参考：containerd, containerd-shim 和 runc 的依存关系\n"});index.add({'id':30,'href':'/study-kubernetes/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':31,'href':'/study-kubernetes/docs/basic/network/','title':"K8s 网络",'content':""});index.add({'id':32,'href':'/study-kubernetes/docs/basic/container/','title':"容器运行时",'content':""});index.add({'id':33,'href':'/study-kubernetes/docs/appendix/attention/','title':"关注",'content':"关注 其他 kubeflow/kubeflow  Machine Learning Toolkit for Kubernetes\nalauda/kube-ovn  A Kubernetes Network Fabric for Enterprises that is Rich in Functions and Easy in Operations https://kube-ovn.io\nrancher/rancher  Rancher 是一个容器管理平台，通过 Rancher 可以实现 Docker 和 Kubernetes 的轻松部署。\nOpenNESS OpenNESS（Open Network Edge Services Software）是一个开源的边缘应用程序管理系统，使服务提供商和企业能够在任何网络的边缘上构建、部署和操作自己的边缘应用程序（ME APP），支持通过简易的方式将运行在 Telco/Public Cloud 中的 APP 迁移到边缘。\nOpenNESS, the easy button to deploy innovative services at the Edge. OpenNESS is an open source reference toolkit that makes it easy to move applications from the Cloud to the Network and On-Premise Edge.\n"});index.add({'id':34,'href':'/study-kubernetes/docs/basic/best-practice/','title':"最佳实践",'content':"Kubernetes 最佳实践 "});index.add({'id':35,'href':'/study-kubernetes/docs/basic/version/','title':"版本",'content':"Kubernetes 版本 "});index.add({'id':36,'href':'/study-kubernetes/docs/basic/debug/','title':"除错",'content':"Kubernetes 除错 参考：监控、日志和排错\n"});index.add({'id':37,'href':'/study-kubernetes/docs/basic/tool/','title':"常用工具",'content':""});index.add({'id':38,'href':'/study-kubernetes/categories/','title':"Categories",'content':""});index.add({'id':39,'href':'/study-kubernetes/docs/','title':"Docs",'content':""});index.add({'id':40,'href':'/study-kubernetes/tags/','title':"Tags",'content':""});index.add({'id':41,'href':'/study-kubernetes/','title':"首页",'content':""});})();
